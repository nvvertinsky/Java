# Архитектура JVM

Разработчику достаточно знать как работает jvm в самых общий чертах. 

### Реализации JVM
  - Oracle HotSpot
  - Oracle JRockit (RIP)
  - IBM J9
  - Excelsior JET
  - Azul
  - SAP, RedHat

### Компилирование исходного кода в байт код. 
  1. С помощью компилятора javac исходный код компилируется в байт-код. 
  2. Файл main.java -> main.class.
  3. Сам байт-код состоит из последовательности инструкций, стэк операдов инструкций, массив локальных переменных.

Как выглядит байт-код:
````
0: iload 3
2: bipush 5
4: iadd
5: istore 4 
````
  
### 1. Загрузчики классов 
Когда вызывается класс в программе, то загрузчик классов загружает его в память. 

Процесс загрузки состоит из этапов: 
  - Загрузка
    - Доступны 3 загрузчика классов: 
	  - Загрузчик классов начальной загрузки (Bootstrap Class Loader) - Загружает классы из стандартной библиотеки java.lang, java.io...
	  - Загрузчик классов расширений (Extension Class Loader) - это загрузчик расширений из каталога $JAVA_HOME/jre/lib/ext 
	  - Загрузчик классов приложений (Application Class Loader) - загружает классы по пути classpath.
	  - Если родительский загрузчик не может найти класс, он делегирует работу дочернему загрузчику классов. Если никто не смог загрузить, то выбрасывают исключение. 
	  - Вместе с классом грузятся супер-классы, суперинферфейсы.
	  - Создается run-time представление класса в области памяти: "runtime constant pool/Meta Space/Permanent Generation".
	  
  - Связывание
    - Верификация байт-кода
	  - Происходит с классом один раз 
	  - Проверка корректности инструкций
	  - Проверка выхода на пределы стэка операндов и локальных переменных
	  - Проверка совместимости типов. 
	- Подготовка
	- Разрешение символьных ссылок
  - Инициализация
    - Вызывает блок статического инициализатора класса {}
	- Первый раз вызываем new
	- При доступе к статическому полю
	- Вызов статического метода 
  
  
### 2. Области памяти.
  1. Область кучи
  2. Область стека
  
  
### 3. Система выполнения.
  - Интепретация байт кода. Интепретатор считывает байт-код и переводчик его в машинный код и выполняет на процессоре. 
  - JIT-компилятор. Работает параллельно программе. Работает только с горячим-кодов. Который часто выполняется. Компилирует его в машинный и сохраняет в памяти. 
    - У JVM есть все необходимые данные чтобы понять какой код горячий. Ведь она его исполняет. Она может профилировать его.
  - Статические компляторы (AOT). Трансляция происходит до исполнения программы. 
    - Возникает вопрос если мы все скомпилировали статически, зачем тогда нужна JVM? JVM это не только исполнения байт-кода, но много чего другого. Например сборка мусора.

### 4. Система meta-информации
  - Рефлексия. JVM позволяет достучаться до классов, полей, методов по имени. 
  - Хранится в области meta-space 

### 5. Нативный интерфейс Java (JNI)
Иногда нужно задействовать не Java код. Например С, С++ или другом системном языке. 
  
### 6. Сборщик мусора. 
  - Что такое мусор? Это те объекты которые не могут использоваться программой.
  - А какие могут использоваться программой? 
    - Объекты в статических полях классов
	- Объекты доступные со стэка Java потоков. 
	- Объекты из JNI ссылок в native методов.

Два базовых алгоритма сборки мусора: 
  - Сначала определяем список гарантированно живых объектов и дальше смотрим на что они ссылаются. Переходим в этот объект и помечаем его живым. Мертвые выметаем. 
  - Stop and copy
    - Сначала определяем список гарантированно живых объектов и не помечаем их, а копируем в новое место в heap.
	- После этого в старом месте остались только мертвые объекты.
	- Освободившееся место может использоваться для новой аллокации. 

Stop the World. - Чтобы собирать мусор нужно остановить все потоки, чтобы определить где мусор.

Методы уменьшения Stop the World паузы: 
  - Инкрементальный. Собирать не весь мусор в паузе. 
  - Параллельный. Собирать мусор во многих потоках в паузе.
  - Одновременный. Собирать мусор одновременно с работой программы. (не останавливать потоки) 
  
  
Поколенная сборка мусора. 
  - Heap делится на две части. 
    - Регион где аллоцируются объекты. Молодое поколение. 
	- Регион где хранятся долго живущие объекты. 
  - Поколеннй GC. 
    - Частый вид инкрементального. 
	- Во время малых сборок удаляем мусор среди молодых объектов. 
	- Объекты, пережившие одну или несколько сборок, перемещаем в область старого поколения. 

